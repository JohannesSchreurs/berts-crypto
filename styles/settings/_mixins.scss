// @import 'typography';
// @import 'layout';

/* =========================================================================  */
/* Resets */
/* =========================================================================  */

/**
 * Fixes VoiceOver not announcing list properly
 * due to `list-style: none`.
 * See:
 * https://unfetteredthoughts.net/2017/09/26/voiceover-and-list-style-type-none/
 *
 * @param {String} $item-selector - List item selector, either of as a class
 *        (results in nesting) or referrencing the element (E) of
 *        the B__E--M  notation. (optional)
 *
 * 1. Prevents any visual issue on load.
 */
 @mixin list-reset-voiceover-fix($item-selector: 'li') {
    $first-char: str-slice($item-selector, 0, 1);
    $selector: '';
    @if $first-char == '.' {
        $selector: $item-selector;
    }
    @elseif $item-selector != 'li' {
        $selector: '&__'+$item-selector;
    }
    @else {
        $selector: '& > li';
    }
    #{$selector}:before {
        content: $zero-width-space;
        position: absolute; /* [1] */
        opacity: 0; /* [1] */
    }
}

/**
 * Resets list styles.
 *
 * @requires @mixin `list-reset-voiceover-fix`
 *
 * @param {String} $item-selector - List item selector, either of as a class
 *        (results in nesting) or referrencing the element (E) of
 *        the B__E--M  notation. (optional)
 */
@mixin list-reset($item-selector: 'li') {
    margin: 0;
    padding-left: 0;
    list-style: none;
    @include list-reset-voiceover-fix($item-selector);
}

/**
 * Resets button styles for a common cross-browser base.
 */
@mixin button-reset {
    appearance: none !important;
    background-color: transparent;
    border: none;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
    text-decoration: none;
    color: inherit;
    font: inherit;
}

/**
 * Resets input styles for a common cross-browser base.
 */
@mixin input-reset {
    border: none;
    border-radius: 0;
    appearance: none;
    background: none;
    min-width: 0;
    font: inherit;
}

/* =========================================================================  */
/* Layout */
/* =========================================================================  */

/**
 * Wraps the bracketed @content into a media query matching
 * the given breakpoint key.
 *
 * @param {String} $from - the min-width breakpoint.
 * @param {String} $to - the max-width breakpoint (optional).
 *
 * @requires @variable $layouts-name.
 * @requires @variable $layouts-break-point.
 */
@mixin media-query($from, $to: false) {
    $from-index: index($layouts-name, $from);
    $from-breakpoint:
        if($from-index, nth($layouts-break-point, $from-index), $from);

    @if $to {
        $to-index: index($layouts-name, $to);
        $to-breakpoint:
            if($to-index, nth($layouts-break-point, $to-index), $to) - 0.01;

        @if ($from-breakpoint == 0) {
            @media only screen and (max-width: $to-breakpoint) {
                @content;
            }
        } @else {
            @media only screen and
            (min-width: $from-breakpoint) and (max-width: $to-breakpoint) {
                @content;
            }
        }
    } @else {
        @if ($from-breakpoint == 0) {
            @content;
        } @else {
            @media only screen and (min-width: $from-breakpoint) {
                @content;
            }
        }
    }
}


/**
 * Clears floating children elements.
 */
@mixin clearfix {
    &:before,
    &:after {
        content: " ";
        display: table;
    }

    &:after {
        clear: both;
    }
}

/* =========================================================================  */
/* Breakpoint loops */
/* =========================================================================  */

/**
 * For a given property, outputs the value for a given list of values matching
 * (binding on index) the $layouts-break-point list.
 *
 * @requires @mixin `media-query`.
 * @requries @variable $layouts-name.
 *
 * @requires mixin `media-query`.
 * @requires @variable $layouts-name.
 */
@mixin responsive($arglist...) {
    $last-results: $arglist;
    $multiplier: 1;
    @if ( type-of(nth($arglist, 1)) != 'list' ) {
        $arglist: $arglist,;
    }
    @each $layout-name in $layouts-name {
        @include media-query($layout-name) {
            @each $args in $arglist {
                $i: index($arglist, $args);
                $property: nth($args, 1);
                $value: nth($args, 2);
                $multipliers: if( length($args) >= 3, nth($args, 3), 1 );
                $adder: if( length($args) >= 4, nth($args, 4), 0 );
                $string: if( length($args) >= 5, nth($args, 5), '' );
                @if (type-of($value) != "map") {
                    $value: ( nth($layouts-name, 1): $value );
                }
                @if map-has-key($value, $layout-name) {
                    @if (type-of($multipliers) == "map") {
                        $multiplier:
                            if( map-get($multipliers, $layout-name),
                            map-get($multipliers, $layout-name), $multiplier );
                    } @else {
                        $multiplier: $multipliers;
                    }
                    $result:
                        unquote(multiply-all(map-get($value, $layout-name),
                        $multiplier, $adder) + $string);
                    @if ( $result != nth($last-results, $i) ) {
                        #{$property}: $result;
                    }
                    $last-results: set-nth($last-results, $i, $result);
                }
            }
        }
    }
}

/* =========================================================================  */
/* Typography */
/* =========================================================================  */

/**
 * Outputs the font-family rule with the fallbak to start with and the webfont
 * once loaded.
 *
 * @param {String} $type - the type of font.
 *
 * @requires @variable $sans-serif-fallback
 * @requires @variable $sans-serif
 * @requires @variable $sans-serif-fallback
 * @requires @variable $sans-serif
 */
@mixin font-family($type) {
    @if $type == 'sans-serif' or $type == 'sans' {
        font-family: $sans-serif;
    }
    @elseif $type == 'sans-serif-bold' {
        font-family: $sans-serif-bold;
    }
    @elseif $type == 'mono' {
        font-family: $mono;
    }
}

/**
 * Outputs all properties and values for each breakpoint in a given font map.
 *
 * @param {String} $font-map-key - the key to a font map in $fonts.
 *
 * @requires @mixin `responsive`.
 * @requires @variable $fonts.
 */
@mixin font($font-map-key) {
    $breakpoint-map: map-get($fonts, $font-map-key);

    @each $breakpoint, $value in $breakpoint-map {
        @include media-query($breakpoint) {
            @each $property, $value in $value {
                @if( $property == 'font-family' ) {
                    @include font-family($value);
                } @else {
                    #{$property}: $value;
                }
            }
        }
    }
}

/**
 * Outputs font size for each breakpoint in a given font map.
 *
 * @param {String} $font-map-key - the key to a font map in $fonts.
 *
 * @requires @mixin `responsive`.
 * @requires @variable $fonts.
 *
 * 1. Get the font map.
 * 2. Get the font size map.
 * 3. Run the responsive mixin with `font-size`
 *    as property and ``$fs-responsive-map` as map.
 */
@mixin font-size-only($font-map-key) {
    $font-map: map-get($fonts, $font-map-key); /* [1] */
    $fs-responsive-map: map-get($font-map, 'font-size'); /* [2] */
    @include responsive('font-size', $fs-responsive-map); /* [3] */
}

/**
 * Outputs a font property value from a given property and breakpoint
 * e.g. : margin: font-property-value('body-sans', 'line-height', 'main');
 *
 * @param {String} $font-map-key - the key to a font map in $fonts.
 * @param {String} $property - the property needed (font-size or line-height).
 * @param {String} $breakpoint - a breakpoint in $layouts-break-point.
 *
 * @requires @variable $fonts.
 *
 * 1. Get the font map.
 * 2. Get the property map.
 * 3. Return the value at a specific breakpoint
 */
@function font-property-value($font-map-key, $property, $breakpoint) {
    $font-map: map-get($fonts, $font-map-key); /* [1] */
    $font-map-property: map-get($font-map, $property); /* [2] */
    $font-map-property-value: map-get($font-map-property, $breakpoint);
    @if $font-map-property-value == '' {
        @warn 'No values are defined for `#{$property}` at breakpoint `#{$breakpoint}`.';
    }
    @return $font-map-property-value; /* [3] */
}

/**
 * Outputs all properties for a given font map at a specific breakpoint.
 *
 * @param {String} $font-map-key - the key to a font map in $fonts.
 * @param {String} $breakpoint - a breakpoint in $layouts-break-point.
 *
 * @requires @mixin `responsive`.
 * @requires @mixin `font-family`.
 * @requires @variable $fonts.
 * @requires @variable $layouts-break-point.
 */
@mixin font-at-breakpoint($font-map-key, $breakpoint) {
    $font-map: map-get($fonts, $font-map-key);
    @each $property-list in $font-map {
        $property: nth($property-list, 1);
        $values-map: nth($property-list, 2);
        @if type-of($values-map) == 'map' {
            @if map-has-key($values-map, $breakpoint) {
                #{$property}: map-get($values-map, $breakpoint);
            }
            @else {
                @warn 'No values are defined for `#{$property}` at breakpoint `#{$breakpoint}`.';
            }
        } @else {
            $value: $values-map;
            @if $property == 'font-family' {
                @include font-family($value);
            } @else {
                #{$property}: #{$value};
            }
        }
    }
}

/* =========================================================================  */
/* Visibility */
/* =========================================================================  */

/**
 * Hide only visually, but have it available for screen readers:
 * https://snook.ca/archives/html_and_css/hiding-content-for-accessibility
 *
 * 1. For long content, line feeds are not interpreted as spaces and small width
 *    causes content to wrap 1 word per line:
 *    https://medium.com/@jessebeach/beware-smushed-off-screen-accessible-text-5952a4c2cbfe
 * 2. Extends the  class to allow the element to be focusable when navigated
 *    to via the keyboard: https://www.drupal.org/node/897638
 */
@mixin visually-hidden {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
    white-space: nowrap; /* [1] */

    &.is-focusable:active,
    &.is-focusable:focus { /* [2] */
        clip: auto;
        height: auto;
        margin: 0;
        overflow: visible;
        position: static;
        width: auto;
        white-space: inherit;
    }
}

/**
 * Reverts visibility of visually hidden element.
 */
@mixin all-screens {
    position: static;
    width: auto;
    height: auto;
    overflow: auto;
}

/* =========================================================================  */
/* Interactivity */
/* =========================================================================  */

/**
 * @mixin `interaction`
 *
 * Outputs bracketed @content as focus state, as well as
 * breakpoint-based hover state.
 *
 * @param {map} $config
 *    @property {string} altering-element - a CSS selector for the element
 *        that will inherit the rules, space-prefixed if not pseudo-element.
 *    @property {bool} remove-outline - whether to remove the outline or not.
 *
 * @requires mixin `media-query`.
 * @requires @variable $layouts-break-point.
 */
@mixin interaction($config: ()) {
    $altering-element: either(map-get($config, 'altering-element'), '');
    $remove-outline: either(map-get($config, 'remove-outline'), false);

    &:focus#{$altering-element} {
        @content;
    }

    @if $remove-outline {
        &:focus {
            outline: none;
        }
    }

    html:not([data-whatintent="touch"]) &:hover#{$altering-element} {
        @content;
    }
}

/**
 * Expands the target area of the inner link to the boundaries
 * of the current CSS selector.
 *
 * @param {map} $config
 *    @property {string} link-selector - a CSS selector for the inner link (optional).
 *    @property {string} pseudo-element - `before` or `after` (optional).
 *    @property {int} z-ghost-link - the z-index to apply to the pseudo element (optional).
 */
@mixin expand-interaction-to-card($config: ()) {
    $link-selector: either(map-get($config, 'link-selector'), 'a');
    $pseudo-element: either(map-get($config, 'pseudo-element'), 'before');
    $z-ghost-link: either(map-get($config, 'z-ghost-link'), 1);

    position: relative;
    z-index: $z-ghost-link - 1;

    #{$link-selector}::#{$pseudo-element} {
        content: ' ';
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: $z-ghost-link;
    }
}

/* =========================================================================  */
/* Decoration */
/* =========================================================================  */

/**
 * Prevents jump when underline is applied on interaction by presetting the
 * bottom padding.
 *
 * @requires global @variable $underline-bottom-padding.
 */
@mixin will-be-underlined {
    padding-bottom: $underline-bottom-padding;
}

/**
 * Underlines text using the background-image technique.
 *
 * @param {map} $config
 *     @property {bool} keep-padding - Set to true to keep previously defined bottom padding. (optional)
 *     @property {string} y-pos - the position of the underline on the Y axis only if $keep-padding is true (optional).
 *     @property {string} display - the type of CSS display (optional).
 *     @property {string} color - the color of the underline (optional).
 *     @property {string} padding-bottom - the padding added to the bottom of the text string (optional).
 *
 * @requires global @variable $underline-bottom-padding.
 * @requires global @variable $underline-thickness.
 */
@mixin underline($config: ()) {
    $keep-padding: either(map-get($config, 'keep-padding'), true);
    $y-pos: either(map-get($config, 'y-pos'), 100%);
    $display: either(map-get($config, 'display'), inline-block);
    $color: either(map-get($config, 'color'), currentColor);
    $padding-bottom: either(map-get($config, 'padding-bottom'), $underline-bottom-padding);

    display: $display;
    background-image: linear-gradient(to bottom, $color, $color);
    background-size: 100% $underline-thickness;
    background-origin: content-box;
    background-repeat: no-repeat;

    @if $keep-padding {
        background-position: 0 $y-pos;

    } @else {
        background-position: left 0 bottom $padding-bottom * -1;
        padding-bottom: $padding-bottom;
    }
}

/**
 * Sets the color of the underline.
 *
 * @param {String} $color - the color of the underline.
 */
@mixin underline-color($color) {
    background-image: linear-gradient(to bottom, $color, $color);
}

/**
 * Sets the position of the underline on the Y axis.
 *
 * @param {String} $y-pos - the position of the underline on the Y axis.
 */
@mixin underline-position($y-pos) {
    background-position-y: $y-pos;
}

/* =========================================================================  */
/* Spacings */
/* =========================================================================  */

/**
 * Define a margin using the predefined margins
 *
 * @param {String} $value - The value of the margin selected
 * @param {String} $property - List item selector, either of as a class
 */
$spacings: map-get($site-spacings, 'm');

@mixin spacing($value: 'l', $property: 'margin-top') {
    #{$property}: map-get($spacings, $value);
    #{$property}: var(--margin-#{$value});
}

/* =========================================================================  */
/* Grid */
/* =========================================================================  */

/**
 * @mixin `grid-helper`
 * @param {string} pseudo (optional) - Possible values: 'before', 'after'
 *
 * Renders visually the grid function on the element.
 */
@mixin grid-helper($pseudo: 'before') {
    $gutter: 2.7%;
    $column: (100% - ($gutter * 5)) / 6;
    $background: '<svg viewBox="0 0 100 10" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">';

    @for $i from 0 through 5 {
        $background: $background + '<rect fill="red" fill-opacity="0.3" x="#{strip-units($column * $i + $gutter * $i)}" width="#{strip-units($column)}" height="10" />';
    }

    $background: $background + '</svg>';

    position: relative;

    &::#{$pseudo} {
        content: '';
        z-index: 1;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: inherit;
        background-image: url('data:image/svg+xml, #{url-encode(unquote($background))} ');
        background-size: 100% 100%;
        background-repeat: no-repeat;
        background-origin: content-box;
        pointer-events: none;
    }
}
